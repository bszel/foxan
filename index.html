<!DOCTYPE html>
<html>
    <head>
        <title>Foxan</title>
        <link rel="stylesheet" href="style.css">
        <script>
            const GRAVITY = 0.1;
            forceMap = Array(50).fill().map(() =>
                Array(50).fill().map(() => new Pair(0, 0)));
            objects = []
            function init() {
                screen.start();
                player = new Object(0, "Player", "Circle", new Pair(1300, 400), new CircSize(30), 10, 0.3, 0, "#ffffff");
                ground = new Object(1, "Static", "Rectangle", new Pair(800, 750), new RectSize(1600, 50), 0, 0.3, 45, "#000000");
                rectangle = new Object(2, "Dynamic", "Rectangle", new Pair(400, 200), new RectSize(50, 100), 10, 0.3, 0, "#00ff00");
                rectangle2 = new Object(6, "Dynamic", "Rectangle", new Pair(1000, 200), new RectSize(50, 75), 30, 0.3, 0, "#0000ff");
                rightWall = new Object(3, "Static", "Rectangle", new Pair(1500, 400), new RectSize(50, 800), 0, 0.5, -10, "#000000");
                ground2 = new Object(4, "Static", "Rectangle", new Pair(800, 750), new RectSize(1600, 50), 0, 0.3, 0, "#000000");
                ground3 = new Object(5, "Static", "Rectangle", new Pair(100, 700), new RectSize(50, 50), 0, 0.3, 0, "#000000");
                objects.push(ground);
                objects.push(ground2);
                objects.push(ground3);
                objects.push(player);
                objects.push(rectangle);
                objects.push(rectangle2);
                objects.push(rightWall);
                background = new Background("background.png");
                playerSprite = new PlayerSprite("foxsprite.png")
                text1 = new Text("30px", "Consolas", "#000000", 10, 25);
                text2 = new Text("30px", "Consolas", "#000000", 10, 50);
            }
            var screen = {
                canvas: document.createElement("canvas"),
                start: function() {
                    this.canvas.width = 1600;
                    this.canvas.height = 800;
                    this.context = this.canvas.getContext("2d");
                    document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                    this.interval = setInterval(updateScreen, 16 + 2 / 3);
                    window.addEventListener('keydown', function (e) {
                        screen.keys = (screen.keys || []);
                        screen.keys[e.keyCode] = (e.type == "keydown");
                    });
                    window.addEventListener('keyup', function (e) {
                        screen.keys = (screen.keys || []);
                        screen.keys[e.keyCode] = (e.type == "keydown");
                    });
                    window.addEventListener('mousedown', function (e) {
                        player.position.x = e.clientX - 160;
                        player.position.y = e.clientY - 80;
                    });
                },
                clear: function() {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }
            var keyboard = {
                w: function() {
                    if (screen.keys && (screen.keys[38] || screen.keys[87])) { return true }
                    else {return false}
                },
                a: function() {
                    if (screen.keys && (screen.keys[37] || screen.keys[65])) { return true }
                    else {return false}
                },
                d: function() {
                    if (screen.keys && (screen.keys[39] || screen.keys[68])) { return true }
                    else {return false}
                }
            }
            var playerController = {
                up: function() {
                    if (player.jump && keyboard.w()) {
                        player.speed.y = -3;
                        playerSprite.playAnimation = false;
                        player.jump = false;
                    }
                },
                left: function() {
                    if (keyboard.a()) {
                        if (player.speed.x > -4) {
                            forceMap[player.id][player.id].x = -2.5;
                        }
                        else {
                            forceMap[player.id][player.id].x = 0;
                        }
                        playerSprite.side = 0;
                        if (player.jump) {
                            playerSprite.playAnimation = true;
                        }
                    }
                },
                right: function() {
                    if (keyboard.d()) {
                        if (player.speed.x < 4) {
                            forceMap[player.id][player.id].x = 2.5;
                        }
                        else {
                            forceMap[player.id][player.id].x = 0;
                        }
                        playerSprite.side = 1;
                        if (player.jump) {
                            playerSprite.playAnimation = true;
                        }
                    }
                },
                idle: function() {
                    if (!keyboard.a() && !keyboard.d()) {
                        forceMap[player.id][player.id].x = 0;
                    }
                },
                update: function() {
                    this.left();
                    this.right();
                    this.up();
                    this.idle();
                }
            }
            function Background(image) {
                this.draw = function() {
                    this.image = new Image();
                    this.image.src = "resources/images/" + image;
                    screen.context.drawImage(this.image, 0, 0);
                }
            }
            function Pair(x, y) {
                this.x = x;
                this.y = y;
            }
            function RectSize(width, height) {
                this.width = width;
                this.height = height;
            }
            function CircSize(radius) {
                this.radius = radius;
            }
            function Object(id, type, shape, position, size, mass, friction, rotation, color) {
                this.id = id;
                this.type = type;
                this.shape = shape;
                this.position = position;
                this.size = size;
                this.mass = mass;
                if (this.type == "Static") {
                    this.mass = 999999999;
                }
                this.friction = friction;
                this.rotation = rotation * Math.PI / 180;
                this.color = color;
                this.acceleration = new Pair(0, 0);
                this.speed = new Pair(0, 0);
                this.force = new Pair(0, 0);
                let context = screen.context;
                if (this.shape == "Rectangle") {
                    this.draw = function() {
                        context.fillStyle = this.color;
                        context.translate(this.position.x, this.position.y);
                        context.rotate(this.rotation);
                        context.translate(-this.position.x, -this.position.y);
                        context.fillRect(this.position.x - this.size.width / 2, this.position.y - this.size.height / 2, this.size.width, this.size.height);
                        context.translate(this.position.x, this.position.y);
                        context.rotate(-this.rotation);
                        context.translate(-this.position.x, -this.position.y);
                    }
                }
                else if (this.shape == "Circle") {
                    this.draw = function() {
                        context.beginPath();
                        context.arc(this.position.x, this.position.y, this.size.radius, 0, 2 * Math.PI);
                        context.stroke();
                        context.fillStyle = this.color;
                        context.fill();
                    }
                }
                if (this.type == "Player" || this.type == "Dynamic") {
                    forceMap[this.id][this.id].y = this.mass * GRAVITY;
                    this.update = function() {
                        this.force.y = forceMap.reduce((sum, row) => sum + row[this.id].y, 0);
                        this.acceleration.y = this.force.y / this.mass;
                        this.speed.y += this.acceleration.y;
                        this.position.y += this.speed.y;
                        this.force.x = forceMap.reduce((sum, row) => sum + row[this.id].x, 0);
                        this.acceleration.x = this.force.x / this.mass;
                        this.speed.x += this.acceleration.x;
                        this.position.x += this.speed.x;
                    }
                }
                if (this.type == "Player") {
                    this.jump = true;
                }
            }
            function PlayerSprite(image) {
                this.image = new Image();
                this.image.src = "resources/sprites/" + image;
                this.size = new RectSize(138, 72);
                this.position = new Pair(0, 0);
                this.animCounter = 0;
                this.side = 0;
                this.playAnimation = false;
                this.update = function() {
                    if (this.playAnimation) {
                        this.animCounter += 0.2;
                        this.playAnimation = false;
                    }
                    this.position.x = player.position.x - (this.size.width / 5) * (2.02 + this.side);
                    this.position.y = player.position.y - this.size.height / 2;
                    let frameWidth = this.image.width / 16;
                    let walkingMod = Math.floor(this.animCounter) % 8;
                    let fullWalking = (this.side * 8 + walkingMod) * frameWidth;
                    screen.context.drawImage(
                        this.image, fullWalking, 0, frameWidth, this.image.height, 
                        this.position.x, this.position.y, this.size.width, this.size.height);
                }
            }
            function Text(width, height, color, x, y) {
                this.width = width;
                this.height = height;
                this.x = x;
                this.y = y;
                this.update = function() {
                    screen.context.font = this.width + " " + this.height;
                    screen.context.fillstyle = color;
                    screen.context.fillText(this.text, this.x, this.y);
                }
            }
            function clamp(val, min_val, max_val) {
                return Math.max(min_val, Math.min(val, max_val));
            }
            function projectCircle(axis, circleCenter, radius) {
                let centerProj = circleCenter.x * axis.x + circleCenter.y * axis.y;
                return {
                    min: centerProj - radius,
                    max: centerProj + radius
                };
            }
            function getClosestPointOnOBB(circle, rect) {
                let dx = circle.position.x - rect.position.x;
                let dy = circle.position.y - rect.position.y;
                let cos = Math.cos(-rect.rotation);
                let sin = Math.sin(-rect.rotation);
                let localX = dx * cos - dy * sin;
                let localY = dx * sin + dy * cos;
                let hw = rect.size.width / 2;
                let hh = rect.size.height / 2;
                let clampedX = clamp(localX, -hw, hw);
                let clampedY = clamp(localY, -hh, hh);
                let worldX = clampedX * cos + clampedY * -sin + rect.position.x;
                let worldY = clampedX * sin + clampedY * cos + rect.position.y;
                return { x: worldX, y: worldY };
            }
            function collidesRC(rect, circle) {
                let rectCorners = getCorners(rect);
                let axes = getAxes(rectCorners);
                let closest = getClosestPointOnOBB(circle, rect);
                let axisToCircle = {
                    x: circle.position.x - closest.x,
                    y: circle.position.y - closest.y
                };
                let len = Math.hypot(axisToCircle.x, axisToCircle.y);
                if (len !== 0) {
                    axisToCircle.x /= len;
                    axisToCircle.y /= len;
                    axes.push(axisToCircle);
                }
                let smallestOverlap = Infinity;
                let mtvAxis = null;
                for (let axis of axes) {
                    let rectProj = projectPolygon(axis, rectCorners);
                    let circleProj = projectCircle(axis, circle.position, circle.size.radius);
                    if (!isOverlapping(rectProj, circleProj)) {
                        return { colliding: false, mtv: null };
                    }
                    let overlap = Math.min(rectProj.max, circleProj.max) - Math.max(rectProj.min, circleProj.min);
                    if (overlap < smallestOverlap) {
                        smallestOverlap = overlap;
                        let direction = {
                            x: circle.position.x - rect.position.x,
                            y: circle.position.y - rect.position.y
                        };
                        let dot = direction.x * axis.x + direction.y * axis.y;
                        mtvAxis = dot < 0 ? { x: -axis.x, y: -axis.y } : axis;
                    }
                }
                let mtv = {
                    x: mtvAxis.x * smallestOverlap,
                    y: mtvAxis.y * smallestOverlap
                };
                return { colliding: true, mtv };
            }
            function setVectorMagnitude(vec, magnitude) {
                let norm = normalize(vec);
                return { x: norm.x * magnitude, y: norm.y * magnitude };
            }
            function normalize(vec) {
                let length = Math.hypot(vec.x, vec.y);
                if (length === 0) return { x: 0, y: 0};
                return { x: vec.x / length, y: vec.y / length };
            }
            function collisionRC(rectangle, circle) {
                let result = collidesRC(rectangle, circle);
                if (result.colliding) {
                    let mtv = result.mtv;
                    if (rectangle.type != "Static") {
                        rectangle.position.x -= mtv.x / 2;
                        rectangle.position.y -= mtv.y / 2;
                    }
                    circle.position.x += mtv.x / 2;
                    circle.position.y += mtv.y / 2;

                    let normal = normalize(mtv);
                    let dot = (a, b) => a.map((x, i) => a[i] * b[i]).reduce((m, n) => m + n);

                    let netForce = {
                        x: forceMap[circle.id][circle.id].x - forceMap[rectangle.id][rectangle.id].x,
                        y: forceMap[circle.id][circle.id].y - forceMap[rectangle.id][rectangle.id].y
                    };
                    let forceAlongNormal = dot([normal.x, normal.y], [netForce.x, netForce.y]);
                    let normalForceMagnitude = forceAlongNormal < 0 ? -forceAlongNormal : 0;
                    let normalForce = setVectorMagnitude(mtv, normalForceMagnitude);

                    let relativeSpeed = { x: rectangle.speed.x - circle.speed.x, y: rectangle.speed.y - circle.speed.y };
                    let relativeSpeedNormal = dot([normal.x, normal.y], [relativeSpeed.x, relativeSpeed.y]);
                    let normalImpulseMagnitude = -relativeSpeedNormal / (1 / circle.mass + 1 / rectangle.mass);
                    let normalImpulse = setVectorMagnitude(mtv, normalImpulseMagnitude);
                    
                    if (rectangle.type != "Static") {
                        rectangle.speed.x += normalImpulse.x / rectangle.mass;
                        rectangle.speed.y += normalImpulse.y / rectangle.mass;
                        forceMap[circle.id][rectangle.id].x = -normalForce.x;
                        forceMap[circle.id][rectangle.id].y = -normalForce.y;
                    }
                    if (circle.type != "Static") {
                        circle.speed.x -= normalImpulse.x / circle.mass;
                        circle.speed.y -= normalImpulse.y / circle.mass;
                        forceMap[rectangle.id][circle.id].x = normalForce.x;
                        forceMap[rectangle.id][circle.id].y = normalForce.y;
                    }
                    if (circle.type == "Player") {
                        if (circle.speed.y >= 0) {
                            circle.jump = true;
                        }
                    }
                }
                else {
                    forceMap[rectangle.id][circle.id].x = 0;
                    forceMap[circle.id][rectangle.id].x = 0;
                    forceMap[rectangle.id][circle.id].y = 0;
                    forceMap[circle.id][rectangle.id].y = 0;
                }
            }
            function getCorners(rectangle) {
                let cx = rectangle.position.x;
                let cy = rectangle.position.y;
                let w = rectangle.size.width;
                let h = rectangle.size.height;
                let cos = Math.cos(rectangle.rotation);
                let sin = Math.sin(rectangle.rotation);
                let hw = w / 2;
                let hh = h / 2;
                return [
                    { x: cx + cos * -hw - sin * -hh, y: cy + sin * -hw + cos * -hh }, // top-left
                    { x: cx + cos * hw - sin * -hh,  y: cy + sin * hw + cos * -hh },  // top-right
                    { x: cx + cos * hw - sin * hh,   y: cy + sin * hw + cos * hh },   // bottom-right
                    { x: cx + cos * -hw - sin * hh,  y: cy + sin * -hw + cos * hh }   // bottom-left
                ];
            }
            function getAxes(points) {
                let axes = [];
                for (let i = 0; i < points.length; i++) {
                    let p1 = points[i];
                    let p2 = points[(i + 1) % points.length];
                    let edge = { x: p2.x - p1.x, y: p2.y - p1.y };
                    let normal = { x: -edge.y, y: edge.x };
                    let length = Math.hypot(normal.x, normal.y);
                    axes.push({ x: normal.x / length, y: normal.y / length });
                }
                return axes;
            }
            function projectPolygon(axis, points) {
                let min = Infinity;
                let max = -Infinity;
                for (let p of points) {
                    let projection = p.x * axis.x + p.y * axis.y;
                    min = Math.min(min, projection);
                    max = Math.max(max, projection);
                }
                return { min, max };
            }
            function isOverlapping(proj1, proj2) {
                return proj1.max >= proj2.min && proj2.max >= proj1.min;
            }
            function collidesRR(r1, r2) {
                let corners1 = getCorners(r1);
                let corners2 = getCorners(r2);
                let axes = getAxes(corners1).concat(getAxes(corners2));
                let smallestOverlap = Infinity;
                let mtvAxis = null;
                for (let axis of axes) {
                    let proj1 = projectPolygon(axis, corners1);
                    let proj2 = projectPolygon(axis, corners2);
                    if (!isOverlapping(proj1, proj2)) {
                        return { colliding: false, mtv: null };
                    }
                    let overlap = Math.min(proj1.max, proj2.max) - Math.max(proj1.min, proj2.min);
                    if (overlap < smallestOverlap) {
                        smallestOverlap = overlap;
                        let d = {
                            x: r2.position.x - r1.position.x,
                            y: r2.position.y - r1.position.y
                        };
                        let dot = d.x * axis.x + d.y * axis.y;
                        mtvAxis = dot < 0 ? { x: -axis.x, y: -axis.y } : axis;
                    }
                }
                let mtv = {
                    x: mtvAxis.x * smallestOverlap,
                    y: mtvAxis.y * smallestOverlap
                };
                return { colliding: true, mtv };
            }
            function collisionRR(r1, r2) {
                let result = collidesRR(r2, r1);
                if (result.colliding) {
                    let mtv = result.mtv;
                    if (r2.type != "Static") {
                        r2.position.x -= mtv.x / 2;
                        r2.position.y -= mtv.y / 2;
                    }
                    r1.position.x += mtv.x / 2;
                    r1.position.y += mtv.y / 2;

                    let normal = normalize(mtv);
                    let dot = (a, b) => a.map((x, i) => a[i] * b[i]).reduce((m, n) => m + n);

                    let netForce = {
                        x: forceMap[r1.id][r1.id].x - forceMap[r2.id][r2.id].x,
                        y: forceMap[r1.id][r1.id].y - forceMap[r2.id][r2.id].y
                    };
                    let forceAlongNormal = dot([normal.x, normal.y], [netForce.x, netForce.y]);
                    let normalForceMagnitude = forceAlongNormal < 0 ? -forceAlongNormal : 0;
                    let normalForce = setVectorMagnitude(mtv, normalForceMagnitude);

                    let relativeSpeed = { x: r2.speed.x - r1.speed.x, y: r2.speed.y - r1.speed.y };
                    let relativeSpeedNormal = dot([normal.x, normal.y], [relativeSpeed.x, relativeSpeed.y]);
                    let normalImpulseMagnitude = -relativeSpeedNormal / (1 / r1.mass + 1 / r2.mass);
                    let normalImpulse = setVectorMagnitude(mtv, normalImpulseMagnitude);

                    if (r1.type != "Static") {
                        r1.speed.x -= normalImpulse.x / r1.mass;
                        r1.speed.y -= normalImpulse.y / r1.mass;
                        forceMap[r2.id][r1.id].x = -normalForce.x;
                        forceMap[r2.id][r1.id].y = -normalForce.y;
                    }
                    if (r2.type != "Static") {
                        r2.speed.x += normalImpulse.x / r2.mass;
                        r2.speed.y += normalImpulse.y / r2.mass;
                        forceMap[r1.id][r2.id].x = normalForce.x;
                        forceMap[r1.id][r2.id].y = normalForce.y;
                    }
                }
                else {
                    forceMap[r1.id][r2.id].x = 0;
                    forceMap[r2.id][r1.id].x = 0;
                    forceMap[r1.id][r2.id].y = 0;
                    forceMap[r2.id][r1.id].y = 0;
                }
            }
            function debugText(object) {
                text1.text = "Fx: " + object.force.x.toFixed(2) + " ax: " + object.acceleration.x.toFixed(2) + " vx: " + object.speed.x.toFixed(2);
                text2.text = "Fy: " + object.force.y.toFixed(2) + " ay: " + object.acceleration.y.toFixed(2) + " vy: " + object.speed.y.toFixed(2);
                text1.update();
                text2.update();
            }
            function updateScreen() {
                screen.clear();
                background.draw();
                playerController.update();
                objects.forEach(object => {
                    if (object.type != "Static") {
                        object.update();
                    }
                });
                for (let i = 0; i < objects.length; i++) {
                    for (let j = i + 1; j < objects.length; j++) {
                        if (objects[i].type != "Static" || objects[j].type != "Static") {
                            if (objects[i].shape == "Rectangle" && objects[j].shape == "Rectangle") {
                                if (objects[i].type == "Static") {
                                    collisionRR(objects[j], objects[i]);
                                }
                                else {
                                    collisionRR(objects[i], objects[j]);
                                }
                            }
                            else if (objects[i].shape == "Rectangle" && objects[j].shape == "Circle") {
                                collisionRC(objects[i], objects[j]);
                            }
                            else if (objects[i].shape == "Circle" && objects[j].shape == "Rectangle") {
                                collisionRC(objects[j], objects[i]);
                            }
                        }
                    }
                }
                objects.forEach(object => {
                    object.draw();
                });
                playerSprite.update();
                debugText(player);
            }
        </script>
    </head>
    <body>
        <script>
            init()
        </script>
    </body>
</html>