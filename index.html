<!DOCTYPE html>
<html>
    <head>
        <title>Foxan</title>
        <link rel="stylesheet" href="style.css">
        <script>
            const GRAVITY = 0.1;
            forceMap = Array(50).fill().map(() =>
                Array(50).fill().map(() => new Pair(0, 0)));
            objects = []
            function init() {
                screen.start();
                player = new Object(0, "Player", "Circle", new Pair(800, 0), new CircSize(30), 10, 0.3, 0, "#ffffff");
                ground = new Object(1, "Static", "Rectangle", new Pair(800, 750), new RectSize(1600, 50), 0, 0.3, 10, "#000000");
                rectangle = new Object(2, "Dynamic", "Rectangle", new Pair(400, 200), new RectSize(50, 100), 10, 0.3, 0, "#00ff00");
                rightWall = new Object(3, "Static", "Rectangle", new Pair(1500, 400), new RectSize(50, 800), 0, 0.5, -10, "#000000");
                objects.push(ground);
                objects.push(player);
                objects.push(rectangle);
                objects.push(rightWall);
                background = new Background("background.png");
                playerSprite = new PlayerSprite("foxsprite.png")
                text1 = new Text("30px", "Consolas", "#000000", 10, 25);
                text2 = new Text("30px", "Consolas", "#000000", 10, 50);
            }
            var screen = {
                canvas: document.createElement("canvas"),
                start: function() {
                    this.canvas.width = 1600;
                    this.canvas.height = 800;
                    this.context = this.canvas.getContext("2d");
                    document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                    this.interval = setInterval(updateScreen, 16 + 2 / 3);
                    window.addEventListener('keydown', function (e) {
                        screen.keys = (screen.keys || []);
                        screen.keys[e.keyCode] = (e.type == "keydown");
                    });
                    window.addEventListener('keyup', function (e) {
                        screen.keys = (screen.keys || []);
                        screen.keys[e.keyCode] = (e.type == "keydown");
                    });
                    window.addEventListener('mousedown', function (e) {
                        player.position.x = e.clientX - 160;
                        player.position.y = e.clientY - 80;
                    });
                },
                clear: function() {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }
            var keyboard = {
                w: function() {
                    if (screen.keys && (screen.keys[38] || screen.keys[87])) { return true }
                    else {return false}
                },
                a: function() {
                    if (screen.keys && (screen.keys[37] || screen.keys[65])) { return true }
                    else {return false}
                },
                d: function() {
                    if (screen.keys && (screen.keys[39] || screen.keys[68])) { return true }
                    else {return false}
                }
            }
            var playerController = {
                up: function() {
                    if (player.jump && keyboard.w()) {
                        player.speed.y = -3;
                        playerSprite.playAnimation = false;
                        player.jump = false;
                    }
                },
                left: function() {
                    if (keyboard.a()) {
                        if (player.speed.x > -4) {
                            forceMap[player.id][player.id].x = -2.5;
                        }
                        else {
                            forceMap[player.id][player.id].x = 0;
                        }
                        playerSprite.side = 0;
                        if (player.jump) {
                            playerSprite.playAnimation = true;
                        }
                    }
                },
                right: function() {
                    if (keyboard.d()) {
                        if (player.speed.x < 4) {
                            forceMap[player.id][player.id].x = 2.5;
                        }
                        else {
                            forceMap[player.id][player.id].x = 0;
                        }
                        playerSprite.side = 1;
                        if (player.jump) {
                            playerSprite.playAnimation = true;
                        }
                    }
                },
                idle: function() {
                    if (!keyboard.a() && !keyboard.d()) {
                        forceMap[player.id][player.id].x = 0;
                    }
                },
                update: function() {
                    this.left();
                    this.right();
                    this.up();
                    this.idle();
                }
            }
            function Background(image) {
                this.draw = function() {
                    this.image = new Image();
                    this.image.src = "resources/images/" + image;
                    screen.context.drawImage(this.image, 0, 0);
                }
            }
            function Pair(x, y) {
                this.x = x;
                this.y = y;
            }
            function RectSize(width, height) {
                this.width = width;
                this.height = height;
            }
            function CircSize(radius) {
                this.radius = radius;
            }
            function Object(id, type, shape, position, size, mass, friction, rotation, color) {
                this.id = id;
                this.type = type;
                this.shape = shape;
                this.position = position;
                this.size = size;
                this.mass = mass;
                if (this.type == "Static") {
                    this.mass = 999999999;
                }
                this.friction = friction;
                this.rotation = rotation * Math.PI / 180;
                this.color = color;
                this.acceleration = new Pair(0, 0);
                this.speed = new Pair(0, 0);
                this.force = new Pair(0, 0);
                let context = screen.context;
                if (this.shape == "Rectangle") {
                    this.draw = function() {
                        context.fillStyle = this.color;
                        context.translate(this.position.x, this.position.y);
                        context.rotate(this.rotation);
                        context.translate(-this.position.x, -this.position.y);
                        context.fillRect(this.position.x - this.size.width / 2, this.position.y - this.size.height / 2, this.size.width, this.size.height);
                        context.translate(this.position.x, this.position.y);
                        context.rotate(-this.rotation);
                        context.translate(-this.position.x, -this.position.y);
                    }
                }
                else if (this.shape == "Circle") {
                    this.draw = function() {
                        context.beginPath();
                        context.arc(this.position.x, this.position.y, this.size.radius, 0, 2 * Math.PI);
                        context.stroke();
                        context.fillStyle = this.color;
                        context.fill();
                    }
                }
                if (this.type == "Player" || this.type == "Dynamic") {
                    forceMap[this.id][this.id].y = this.mass * GRAVITY;
                    this.update = function() {
                        this.force.y = forceMap.reduce((sum, row) => sum + row[this.id].y, 0);
                        this.acceleration.y = this.force.y / this.mass;
                        this.speed.y += this.acceleration.y;
                        this.position.y += this.speed.y;
                        this.force.x = forceMap.reduce((sum, row) => sum + row[this.id].x, 0);
                        this.acceleration.x = this.force.x / this.mass;
                        this.speed.x += this.acceleration.x;
                        this.position.x += this.speed.x;
                    }
                }
                if (this.type == "Player") {
                    this.jump = true;
                }
            }
            function PlayerSprite(image) {
                this.image = new Image();
                this.image.src = "resources/sprites/" + image;
                this.size = new RectSize(138, 72);
                this.position = new Pair(0, 0);
                this.animCounter = 0;
                this.side = 0;
                this.playAnimation = false;
                this.update = function() {
                    if (this.playAnimation) {
                        this.animCounter += 0.2;
                        this.playAnimation = false;
                    }
                    this.position.x = player.position.x - (this.size.width / 5) * (2.02 + this.side);
                    this.position.y = player.position.y - this.size.height / 2;
                    let frameWidth = this.image.width / 16;
                    let walkingMod = Math.floor(this.animCounter) % 8;
                    let fullWalking = (this.side * 8 + walkingMod) * frameWidth;
                    screen.context.drawImage(
                        this.image, fullWalking, 0, frameWidth, this.image.height, 
                        this.position.x, this.position.y, this.size.width, this.size.height);
                }
            }
            function Text(width, height, color, x, y) {
                this.width = width;
                this.height = height;
                this.x = x;
                this.y = y;
                this.update = function() {
                    screen.context.font = this.width + " " + this.height;
                    screen.context.fillstyle = color;
                    screen.context.fillText(this.text, this.x, this.y);
                }
            }
            function clamp(val, min_val, max_val) {
                return Math.max(min_val, Math.min(val, max_val));
            }
            function collidesRC(rectangle, circle) {
                let dx = circle.position.x - rectangle.position.x;
                let dy = circle.position.y - rectangle.position.y;
                let cos = Math.cos(-rectangle.rotation);
                let sin = Math.sin(-rectangle.rotation);
                let localCircleX = dx * cos - dy * sin;
                let localCircleY = dx * sin + dy * cos;
                let closestX = clamp(localCircleX, -rectangle.size.width / 2, rectangle.size.width / 2);
                let closestY = clamp(localCircleY, -rectangle.size.height / 2, rectangle.size.height / 2);
                let distance = Math.sqrt((localCircleX - closestX) ** 2 + (localCircleY - closestY) ** 2);
                return distance < circle.size.radius;
            }
            function collisionRC(rectangle, circle) {
                if (collidesRC(rectangle, circle)) {
                    let circleMomentum = new Pair(0, 0);
                    circleMomentum.x = circle.mass * circle.speed.x;
                    circleMomentum.y = circle.mass * circle.speed.y;
                    let rectMomentum = new Pair(0, 0);
                    rectMomentum.x = rectangle.mass * rectangle.speed.x;
                    rectMomentum.y = rectangle.mass * rectangle.speed.y;
                    let newSpeed = new Pair(0, 0);
                    newSpeed.x = (circleMomentum.x + rectMomentum.x) / (circle.mass + rectangle.mass);
                    newSpeed.y = (circleMomentum.y + rectMomentum.y) / (circle.mass + rectangle.mass);
                    if (rectangle.type != "Static") {
                        rectangle.speed.x = newSpeed.x;
                        rectangle.speed.y = newSpeed.y;
                        forceMap[circle.id][rectangle.id].x = forceMap[circle.id][circle.id].x - forceMap[rectangle.id][rectangle.id].x;
                        forceMap[circle.id][rectangle.id].y = forceMap[circle.id][circle.id].y;
                    }
                    if (circle.type != "Static") {
                        circle.speed.x = newSpeed.x;
                        circle.speed.y = newSpeed.y;
                        forceMap[rectangle.id][circle.id].x = forceMap[rectangle.id][rectangle.id].x - forceMap[circle.id][circle.id].x;
                        forceMap[rectangle.id][circle.id].y = -forceMap[circle.id][circle.id].y;
                    }
                    if (circle.type == "Player") {
                        if (circle.speed.y >= 0) {
                            circle.jump = true;
                        }
                    }
                }
                else {
                    forceMap[rectangle.id][circle.id].x = 0;
                    forceMap[circle.id][rectangle.id].x = 0;
                    forceMap[rectangle.id][circle.id].y = 0;
                    forceMap[circle.id][rectangle.id].y = 0;
                }
            }
            function getCorners(rectangle) {
                let cx = rectangle.position.x;
                let cy = rectangle.position.y;
                let w = rectangle.size.width;
                let h = rectangle.size.height;
                let cos = Math.cos(rectangle.rotation);
                let sin = Math.sin(rectangle.rotation);
                let hw = w / 2;
                let hh = h / 2;
                return [
                    { x: cx + cos * -hw - sin * -hh, y: cy + sin * -hw + cos * -hh }, // top-left
                    { x: cx + cos * hw - sin * -hh,  y: cy + sin * hw + cos * -hh },  // top-right
                    { x: cx + cos * hw - sin * hh,   y: cy + sin * hw + cos * hh },   // bottom-right
                    { x: cx + cos * -hw - sin * hh,  y: cy + sin * -hw + cos * hh }   // bottom-left
                ];
            }
            function getAxes(points) {
                let axes = [];
                for (let i = 0; i < points.length; i++) {
                    let p1 = points[i];
                    let p2 = points[(i + 1) % points.length];
                    let edge = { x: p2.x - p1.x, y: p2.y - p1.y };
                    let normal = { x: -edge.y, y: edge.x };
                    let length = Math.hypot(normal.x, normal.y);
                    axes.push({ x: normal.x / length, y: normal.y / length });
                }
                return axes;
            }
            function projectPolygon(axis, points) {
                let min = Infinity;
                let max = -Infinity;
                for (let p of points) {
                    let projection = p.x * axis.x + p.y * axis.y;
                    min = Math.min(min, projection);
                    max = Math.max(max, projection);
                }
                return { min, max };
            }
            function isOverlapping(proj1, proj2) {
                return proj1.max >= proj2.min && proj2.max >= proj1.min;
            }
            function collidesRR(r1, r2) {
                let corners1 = getCorners(r1);
                let corners2 = getCorners(r2);
                let axes = getAxes(corners1).concat(getAxes(corners2));
                for (let axis of axes) {
                    let proj1 = projectPolygon(axis, corners1);
                    let proj2 = projectPolygon(axis, corners2);
                    if (!isOverlapping(proj1, proj2)) {
                        return false;
                    }
                }
                return true;
            }
            function collisionRR(r1, r2) {
                if (collidesRR(r1, r2)) {
                    let r2Momentum = new Pair(0, 0);
                    r2Momentum.x = r2.mass * r2.speed.x;
                    r2Momentum.y = r2.mass * r2.speed.y;
                    let r1Momentum = new Pair(0, 0);
                    r1Momentum.x = r1.mass * r1.speed.x;
                    r1Momentum.y = r1.mass * r1.speed.y;
                    let newSpeed = new Pair(0, 0);
                    newSpeed.x = (r1Momentum.x + r2Momentum.x) / (r1.mass + r2.mass);
                    newSpeed.y = (r1Momentum.y + r2Momentum.y) / (r1.mass + r2.mass);
                    if (r1.type != "Static") {
                        r1.speed.x = newSpeed.x;
                        r1.speed.y = newSpeed.y;
                        forceMap[r2.id][r1.id].x = forceMap[r2.id][r2.id].x - forceMap[r1.id][r1.id].x;
                        forceMap[r2.id][r1.id].y = -forceMap[r1.id][r1.id].y;
                    }
                    if (r2.type != "Static") {
                        r2.speed.x = newSpeed.x;
                        r2.speed.y = newSpeed.y;
                        forceMap[r1.id][r2.id].x = forceMap[r1.id][r1.id].x - forceMap[r2.id][r2.id].x;
                        forceMap[r1.id][r2.id].y = forceMap[r1.id][r1.id].y;
                    }
                }
                else {
                    forceMap[r1.id][r2.id].x = 0;
                    forceMap[r2.id][r1.id].x = 0;
                    forceMap[r1.id][r2.id].y = 0;
                    forceMap[r2.id][r1.id].y = 0;
                }
            }
            function debugText(object) {
                text1.text = "Fx: " + object.force.x.toFixed(2) + " ax: " + object.acceleration.x.toFixed(2) + " vx: " + object.speed.x.toFixed(2);
                text2.text = "Fy: " + object.force.y.toFixed(2) + " ay: " + object.acceleration.y.toFixed(2) + " vy: " + object.speed.y.toFixed(2);
                text1.update();
                text2.update();
            }
            function updateScreen() {
                screen.clear();
                background.draw();
                playerController.update();
                objects.forEach(object => {
                    if (object.type != "Static") {
                        object.update();
                    }
                });
                for (let i = 0; i < objects.length; i++) {
                    for (let j = i + 1; j < objects.length; j++) {
                        if (objects[i].type != "Static" || objects[j].type != "Static") {
                            if (objects[i].shape == "Rectangle" && objects[j].shape == "Rectangle") {
                                collisionRR(objects[i], objects[j]);
                            }
                            else if (objects[i].shape == "Rectangle" && objects[j].shape == "Circle") {
                                collisionRC(objects[i], objects[j]);
                            }
                            else if (objects[i].shape == "Circle" && objects[j].shape == "Rectangle") {
                                collisionRC(objects[j], objects[i]);
                            }
                        }
                    }
                }
                objects.forEach(object => {
                    object.draw();
                });
                playerSprite.update();
                debugText(player);
            }
        </script>
    </head>
    <body>
        <script>
            init()
        </script>
    </body>
</html>