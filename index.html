<!DOCTYPE html>
<html>
    <head>
        <title>Foxan</title>
        <link rel="stylesheet" href="style.css">
        <script>
            const GRAVITY = 0.1;
            forceMap = Array(50).fill().map(() =>
                Array(50).fill().map(() => new Pair(0, 0)));
            objects = []
            function init() {
                screen.start();
                player = new Object(0, "Player", "Circle", new Pair(800, 0), new CircSize(30), 10, 0.3, 0, "#ffffff");
                ground = new Object(1, "Static", "Rectangle", new Pair(0, 750), new RectSize(1600, 50), 0, 0.3, 10, "#000000");
                rectangle = new Object(2, "Dynamic", "Rectangle", new Pair(400, 200), new RectSize(50, 100), 10, 0.3, 0, "#00ff00");
                rightWall = new Object(3, "Static", "Rectangle", new Pair(1500, 0), new RectSize(50, 800), 0, 0.5, -10, "#000000");
                objects.push(ground);
                objects.push(player);
                objects.push(rectangle);
                objects.push(rightWall);
                background = new Background("background.png");
                playerSprite = new PlayerSprite("foxsprite.png")
                text1 = new Text("30px", "Consolas", "#000000", 10, 25);
                text2 = new Text("30px", "Consolas", "#000000", 10, 50);
            }
            var screen = {
                canvas: document.createElement("canvas"),
                start: function() {
                    this.canvas.width = 1600;
                    this.canvas.height = 800;
                    this.context = this.canvas.getContext("2d");
                    document.body.insertBefore(this.canvas, document.body.childNodes[0]);
                    this.interval = setInterval(updateScreen, 16 + 2 / 3);
                    window.addEventListener('keydown', function (e) {
                        screen.keys = (screen.keys || []);
                        screen.keys[e.keyCode] = (e.type == "keydown");
                    });
                    window.addEventListener('keyup', function (e) {
                        screen.keys = (screen.keys || []);
                        screen.keys[e.keyCode] = (e.type == "keydown");
                    });
                    window.addEventListener('mousedown', function (e) {
                        player.position.x = e.clientX - 160;
                        player.position.y = e.clientY - 80;
                    });
                },
                clear: function() {
                    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
                }
            }
            var keyboard = {
                w: function() {
                    if (screen.keys && (screen.keys[38] || screen.keys[87])) { return true }
                    else {return false}
                },
                a: function() {
                    if (screen.keys && (screen.keys[37] || screen.keys[65])) { return true }
                    else {return false}
                },
                d: function() {
                    if (screen.keys && (screen.keys[39] || screen.keys[68])) { return true }
                    else {return false}
                }
            }
            var playerController = {
                up: function() {
                    if (player.jump && keyboard.w()) {
                        player.speed.y = -3;
                        playerSprite.playAnimation = false;
                        player.jump = false;
                    }
                },
                left: function() {
                    if (keyboard.a()) {
                        if (player.speed.x > -4) {
                            forceMap[player.id][player.id].x = -2.5;
                        }
                        else {
                            forceMap[player.id][player.id].x = 0;
                        }
                        playerSprite.side = 0;
                        if (player.jump) {
                            playerSprite.playAnimation = true;
                        }
                    }
                },
                right: function() {
                    if (keyboard.d()) {
                        if (player.speed.x < 4) {
                            forceMap[player.id][player.id].x = 2.5;
                        }
                        else {
                            forceMap[player.id][player.id].x = 0;
                        }
                        playerSprite.side = 1;
                        if (player.jump) {
                            playerSprite.playAnimation = true;
                        }
                    }
                },
                idle: function() {
                    if (!keyboard.a() && !keyboard.d()) {
                        forceMap[player.id][player.id].x = 0;
                    }
                },
                update: function() {
                    this.left();
                    this.right();
                    this.up();
                    this.idle();
                }
            }
            function Background(image) {
                this.draw = function() {
                    this.image = new Image();
                    this.image.src = "resources/images/" + image;
                    screen.context.drawImage(this.image, 0, 0);
                }
            }
            function Pair(x, y) {
                this.x = x;
                this.y = y;
            }
            function RectSize(width, height) {
                this.width = width;
                this.height = height;
            }
            function CircSize(radius) {
                this.radius = radius;
            }
            function Object(id, type, shape, position, size, mass, friction, rotation, color) {
                this.id = id;
                this.type = type;
                this.shape = shape;
                this.position = position;
                this.size = size;
                this.mass = mass;
                if (this.type == "Static") {
                    this.mass = 999999999;
                }
                this.friction = friction;
                this.rotation = rotation;
                this.color = color;
                this.acceleration = new Pair(0, 0);
                this.speed = new Pair(0, 0);
                this.force = new Pair(0, 0);
                let context = screen.context;
                if (this.shape == "Rectangle") {
                    this.draw = function() {
                        context.fillStyle = this.color;
                        context.translate((this.position.x + this.size.width / 2), (this.position.y + this.size.height / 2));
                        context.rotate((this.rotation * Math.PI) / 180);
                        context.translate(-(this.position.x + this.size.width / 2), -(this.position.y + this.size.height / 2));
                        context.fillRect(this.position.x, this.position.y, this.size.width, this.size.height);
                        context.translate((this.position.x + this.size.width / 2), (this.position.y + this.size.height / 2));
                        context.rotate((-this.rotation * Math.PI) / 180);
                        context.translate(-(this.position.x + this.size.width / 2), -(this.position.y + this.size.height / 2));
                    }
                }
                else if (this.shape == "Circle") {
                    this.draw = function() {
                        context.beginPath();
                        context.arc(this.position.x, this.position.y, this.size.radius, 0, 2 * Math.PI);
                        context.stroke();
                        context.fillStyle = this.color;
                        context.fill();
                    }
                }
                if (this.type == "Player" || this.type == "Dynamic") {
                    forceMap[this.id][this.id].y = this.mass * GRAVITY;
                    this.update = function() {
                        this.force.y = forceMap.reduce((sum, row) => sum + row[this.id].y, 0);
                        this.acceleration.y = this.force.y / this.mass;
                        this.speed.y += this.acceleration.y;
                        this.position.y += this.speed.y;
                        this.force.x = forceMap.reduce((sum, row) => sum + row[this.id].x, 0);
                        this.acceleration.x = this.force.x / this.mass;
                        this.speed.x += this.acceleration.x;
                        this.position.x += this.speed.x;
                    }
                }
                if (this.type == "Player") {
                    this.jump = true;
                }
            }
            function PlayerSprite(image) {
                this.image = new Image();
                this.image.src = "resources/sprites/" + image;
                this.size = new RectSize(138, 72);
                this.position = new Pair(0, 0);
                this.animCounter = 0;
                this.side = 0;
                this.playAnimation = false;
                this.update = function() {
                    if (this.playAnimation) {
                        this.animCounter += 0.2;
                        this.playAnimation = false;
                    }
                    this.position.x = player.position.x - (this.size.width / 5) * (2.02 + this.side);
                    this.position.y = player.position.y - this.size.height / 2;
                    let frameWidth = this.image.width / 16;
                    let walkingMod = Math.floor(this.animCounter) % 8;
                    let fullWalking = (this.side * 8 + walkingMod) * frameWidth;
                    screen.context.drawImage(
                        this.image, fullWalking, 0, frameWidth, this.image.height, 
                        this.position.x, this.position.y, this.size.width, this.size.height);
                }
            }
            function Text(width, height, color, x, y) {
                this.width = width;
                this.height = height;
                this.x = x;
                this.y = y;
                this.update = function() {
                    screen.context.font = this.width + " " + this.height;
                    screen.context.fillstyle = color;
                    screen.context.fillText(this.text, this.x, this.y);
                }
            }
            function clamp(val, min_val, max_val) {
                return Math.max(min_val, Math.min(val, max_val));
            }
            function pushCircle(circle, rectangle) {
                let left = circle.position.x - rectangle.position.x;
                let right = rectangle.position.x + rectangle.size.width - circle.position.x;
                let top = circle.position.y - rectangle.position.y;
                let bottom = rectangle.position.y + rectangle.size.height - circle.position.y;
                let min_dist = Math.min(left, right, top, bottom);
                if (min_dist == left) {
                    circle.position.x = rectangle.position.x - circle.size.radius;
                }
                else if (min_dist == right) {
                    circle.position.x = rectangle.position.x + rectangle.size.width + circle.size.radius;
                }
                else if (min_dist == top) {
                    circle.position.y = rectangle.position.y - circle.size.radius;
                }
                else if (min_dist == bottom) {
                    circle.position.y = rectangle.position.y + rectangle.size.height + circle.size.radius;
                }
            }
            function pushRectangle(r1, r2) {
                let r1_x1 = r1.position.x;
                let r1_x2 = r1.position.x + r1.size.width;
                let r1_y1 = r1.position.y;
                let r1_y2 = r1.position.y + r1.size.height;
                let r2_x1 = r2.position.x;
                let r2_x2 = r2.position.x + r2.size.width;
                let r2_y1 = r2.position.y;
                let r2_y2 = r2.position.y + r2.size.height;
                let overlap_x = Math.min(r1_x2, r2_x2) - Math.max(r1_x1, r2_x1);
                let overlap_y = Math.min(r1_y2, r2_y2) - Math.max(r1_y1, r2_y1);
                if (overlap_x < overlap_y) {
                    if (r1_x1 + r1.size.width / 2 < r2_x1 + r2.size.width / 2) {
                        move_x = -overlap_x;
                    }
                    else {
                        move_x = overlap_x;
                    }
                    move_y = 0;
                }
                else {
                    if (r1_y1 + r1.size.height / 2 < r2_y1 + r2.size.height / 2) {
                        move_y = -overlap_y;
                    }
                    else {
                        move_y = overlap_y;
                    }
                    move_x = 0;
                }
                r1.position.x += move_x;
                r1.position.y += move_y;
            }
            function collisionRC(rectangle, circle) {
                let dx = circle.position.x - (rectangle.position.x + rectangle.size.width / 2);
                let dy = circle.position.y - (rectangle.position.y + rectangle.size.height / 2);
                let cos = Math.cos(-rectangle.rotation * Math.PI / 180);
                let sin = Math.sin(-rectangle.rotation * Math.PI / 180);
                let localCircleX = dx * cos - dy * sin;
                let localCircleY = dx * sin + dy * cos;
                let closestX = clamp(localCircleX, -rectangle.size.width / 2, rectangle.size.width / 2);
                let closestY = clamp(localCircleY, -rectangle.size.height / 2, rectangle.size.height / 2);
                let distance = Math.sqrt((localCircleX - closestX) ** 2 + (localCircleY - closestY) ** 2);
                if (distance < circle.size.radius) {
                    let circleMomentum = new Pair(0, 0);
                    circleMomentum.x = circle.mass * circle.speed.x;
                    circleMomentum.y = circle.mass * circle.speed.y;
                    let rectMomentum = new Pair(0, 0);
                    rectMomentum.x = rectangle.mass * rectangle.speed.x;
                    rectMomentum.y = rectangle.mass * rectangle.speed.y;
                    let newSpeed = new Pair(0, 0);
                    newSpeed.x = (circleMomentum.x + rectMomentum.x) / (circle.mass + rectangle.mass);
                    newSpeed.y = (circleMomentum.y + rectMomentum.y) / (circle.mass + rectangle.mass);
                    if (rectangle.type != "Static") {
                        rectangle.speed.x = newSpeed.x;
                        rectangle.speed.y = newSpeed.y;
                        forceMap[circle.id][rectangle.id].x = forceMap[circle.id][circle.id].x - forceMap[rectangle.id][rectangle.id].x;
                        forceMap[circle.id][rectangle.id].y = forceMap[circle.id][circle.id].y;
                    }
                    if (circle.type != "Static") {
                        circle.speed.x = newSpeed.x;
                        circle.speed.y = newSpeed.y;
                        forceMap[rectangle.id][circle.id].x = forceMap[rectangle.id][rectangle.id].x - forceMap[circle.id][circle.id].x;
                        forceMap[rectangle.id][circle.id].y = -forceMap[circle.id][circle.id].y;
                    }
                    // pushCircle(circle, rectangle);
                    if (circle.type == "Player") {
                        if (circle.speed.y >= 0) {
                            circle.jump = true;
                        }
                    }
                }
                else {
                    forceMap[rectangle.id][circle.id].x = 0;
                    forceMap[circle.id][rectangle.id].x = 0;
                    forceMap[rectangle.id][circle.id].y = 0;
                    forceMap[circle.id][rectangle.id].y = 0;
                }
            }
            function collisionRR(r1, r2) {
                let dx = Math.max(0, Math.max(r2.position.x - (r1.position.x + r1.size.width), r1.position.x - (r2.position.x + r2.size.width)));
                let dy = Math.max(0, Math.max(r2.position.y - (r1.position.y + r1.size.height), r1.position.y - (r2.position.y + r2.size.height)));
                let distance = Math.sqrt(dx ** 2 + dy ** 2);
                if (distance == 0) {
                    let r2Momentum = new Pair(0, 0);
                    r2Momentum.x = r2.mass * r2.speed.x;
                    r2Momentum.y = r2.mass * r2.speed.y;
                    let r1Momentum = new Pair(0, 0);
                    r1Momentum.x = r1.mass * r1.speed.x;
                    r1Momentum.y = r1.mass * r1.speed.y;
                    let newSpeed = new Pair(0, 0);
                    newSpeed.x = (r1Momentum.x + r2Momentum.x) / (r1.mass + r2.mass);
                    newSpeed.y = (r1Momentum.y + r2Momentum.y) / (r1.mass + r2.mass);
                    if (r1.type != "Static") {
                        r1.speed.x = newSpeed.x;
                        r1.speed.y = newSpeed.y;
                        forceMap[r2.id][r1.id].x = forceMap[r2.id][r2.id].x - forceMap[r1.id][r1.id].x;
                        forceMap[r2.id][r1.id].y = -forceMap[r1.id][r1.id].y;
                    }
                    if (r2.type != "Static") {
                        r2.speed.x = newSpeed.x;
                        r2.speed.y = newSpeed.y;
                        forceMap[r1.id][r2.id].x = forceMap[r1.id][r1.id].x - forceMap[r2.id][r2.id].x;
                        forceMap[r1.id][r2.id].y = forceMap[r1.id][r1.id].y;
                    }
                    if (r1.type == "Static") {
                        pushRectangle(r2, r1);
                    }
                    else {
                        pushRectangle(r1, r2);
                    }
                }
                else {
                    forceMap[r1.id][r2.id].x = 0;
                    forceMap[r2.id][r1.id].x = 0;
                    forceMap[r1.id][r2.id].y = 0;
                    forceMap[r2.id][r1.id].y = 0;
                }
            }
            function debugText(object) {
                text1.text = "Fx: " + object.force.x.toFixed(2) + " ax: " + object.acceleration.x.toFixed(2) + " vx: " + object.speed.x.toFixed(2);
                text2.text = "Fy: " + object.force.y.toFixed(2) + " ay: " + object.acceleration.y.toFixed(2) + " vy: " + object.speed.y.toFixed(2);
                text1.update();
                text2.update();
            }
            function updateScreen() {
                screen.clear();
                background.draw();
                playerController.update();
                objects.forEach(object => {
                    if (object.type != "Static") {
                        object.update();
                    }
                });
                for (let i = 0; i < objects.length; i++) {
                    for (let j = i + 1; j < objects.length; j++) {
                        if (objects[i].type != "Static" || objects[j].type != "Static") {
                            if (objects[i].shape == "Rectangle" && objects[j].shape == "Rectangle") {
                                collisionRR(objects[i], objects[j]);
                            }
                            else if (objects[i].shape == "Rectangle" && objects[j].shape == "Circle") {
                                collisionRC(objects[i], objects[j]);
                            }
                            else if (objects[i].shape == "Circle" && objects[j].shape == "Rectangle") {
                                collisionRC(objects[j], objects[i]);
                            }
                        }
                    }
                }
                objects.forEach(object => {
                    object.draw();
                });
                playerSprite.update();
                debugText(player);
            }
        </script>
    </head>
    <body>
        <script>
            init()
        </script>
    </body>
</html>